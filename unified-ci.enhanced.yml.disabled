name: Unified Monorepo CI (Enhanced Draft + Badge + Baseline + Flaky)

on:
  pull_request:
    branches: [ main ]
  push:
    branches: [ main ]
  workflow_dispatch: {}

concurrency:
  group: unified-ci-${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

env:
  SWIFT_FORMAT_CONFIG: Tools/Config/UNIFIED_SWIFTFORMAT_ROOT
  SWIFTLINT_CONFIG: Tools/Config/UNIFIED_SWIFTLINT_ROOT.yml
  ROOT_CONFIG_DIR: Tools/Config
  COVERAGE_DIR: coverage
  XCODE_COVERAGE_RESULT_BUNDLE: xcodebuild/TestResults.xcresult
  COVERAGE_MIN_PCT: 40
  COVERAGE_BASELINE_FILE: Tools/Automation/coverage-baseline.json
  FLAKY_THRESHOLD: 2

jobs:
  prepare-matrix:
    runs-on: macos-14
    outputs:
      project_list: ${{ steps.set-matrix.outputs.project_list }}
      has_baseline: ${{ steps.baseline.outputs.has_baseline }}
      baseline_json: ${{ steps.baseline.outputs.baseline_json }}
    steps:
      - uses: actions/checkout@34e114876b0b11c390a56381ad16ebd13914f8d5
      - id: set-matrix
        run: |
          set -euo pipefail
          projects=$(find Projects -maxdepth 2 -name '*.xcodeproj' -type d | sed 's|/[^/]*\\.xcodeproj||' | sort -u)
          if [[ -z "$projects" ]]; then projects="Projects"; fi
          json=$(jq -Rn '[inputs|split("\n")|.[]]|map(select(length>0))' <<<"$projects")
          echo "project_list=$json" >> "$GITHUB_OUTPUT"
          echo "Detected: $json"
      - id: baseline
        run: |
          if [[ -f "$COVERAGE_BASELINE_FILE" ]]; then echo "has_baseline=true" >> $GITHUB_OUTPUT; echo "baseline_json=$(jq -c . $COVERAGE_BASELINE_FILE)" >> $GITHUB_OUTPUT; else echo "has_baseline=false" >> $GITHUB_OUTPUT; echo 'baseline_json={}' >> $GITHUB_OUTPUT; fi

  build-test:
    runs-on: macos-14
    needs: prepare-matrix
    strategy:
      fail-fast: false
      matrix:
        project: ${{ fromJson(needs.prepare-matrix.outputs.project_list) }}
    steps:
      - uses: actions/checkout@34e114876b0b11c390a56381ad16ebd13914f8d5
      - name: Select Xcode
        run: sudo xcode-select -s /Applications/Xcode.app
      - name: Cache DerivedData
        uses: actions/cache@0057852bfaa89a56745cba8c7296529d2fc39830
        with:
          path: ~/Library/Developer/Xcode/DerivedData
          key: dd-${{ runner.os }}-${{ hashFiles('**/*.xcodeproj/project.pbxproj') }}
          restore-keys: dd-${{ runner.os }}-
      - name: Discover Schemes
        id: schemes
        working-directory: ${{ matrix.project }}
        run: |
          set -euo pipefail
          mapfile -t schemes < <(xcodebuild -list -json 2>/dev/null | jq -r '.project.schemes[]?') || true
          if [[ ${#schemes[@]} -eq 0 ]]; then echo "has_schemes=false" >> $GITHUB_OUTPUT; else echo "has_schemes=true" >> $GITHUB_OUTPUT; printf '%s\n' "${schemes[@]}" > ../schemes_${{ matrix.project//\//_ }}.txt; fi
      - name: SwiftPM Cache (.build)
        if: steps.schemes.outputs.has_schemes == 'false'
        uses: actions/cache@0057852bfaa89a56745cba8c7296529d2fc39830
        with:
          path: ${{ matrix.project }}/.build
          key: spm-${{ runner.os }}-${{ hashFiles(format('{0}/Package.swift', matrix.project)) }}-${{ hashFiles(format('{0}/Package.resolved', matrix.project)) }}
          restore-keys: spm-${{ runner.os }}-${{ hashFiles(format('{0}/Package.swift', matrix.project)) }}-
      - name: Unified Format & Lint
        uses: ./Tools/Automation/actions/format-lint
        with:
          mode: check
          scope: all
  - name: SwiftPM Build & Test
        if: steps.schemes.outputs.has_schemes == 'false'
        working-directory: ${{ matrix.project }}
        run: |
          if [[ -f Package.swift ]]; then
            swift test --parallel --enable-code-coverage 2>&1 | tee ../spm_test_log_${{ matrix.project//\//_ }}.txt
            mkdir -p ../$COVERAGE_DIR/swiftpm/${{ matrix.project }}
            profs=$(find .build -name '*.profraw')
            if [[ -n "$profs" ]]; then
              llvm-profdata merge -sparse $profs -o ../$COVERAGE_DIR/swiftpm/${{ matrix.project }}/coverage.profdata || true
              bin=$(find .build -type f -perm +111 -name '*Tests' | head -1 || true)
              if [[ -n "$bin" ]]; then
                llvm-cov export -format=json -instr-profile=../$COVERAGE_DIR/swiftpm/${{ matrix.project }}/coverage.profdata $bin > ../$COVERAGE_DIR/swiftpm/${{ matrix.project }}/coverage.json || true
                total=$(jq '[.data[].files[].segments[] | select(.[2] > 0)] | length' ../$COVERAGE_DIR/swiftpm/${{ matrix.project }}/coverage.json 2>/dev/null || echo 0)
                covered=$(jq '[.data[].files[].segments[] | select(.[2] > 0 and .[3] > 0)] | length' ../$COVERAGE_DIR/swiftpm/${{ matrix.project }}/coverage.json 2>/dev/null || echo 0)
        if [[ $total -gt 0 ]]; then pct=$(awk -v c="$covered" -v t="$total" 'BEGIN{printf "%.2f", (c/t)*100}'); echo $pct > ../$COVERAGE_DIR/swiftpm/${{ matrix.project }}/line_coverage_pct.txt; fi
              fi
            fi
          fi
      - name: Xcode Build & Test
        if: steps.schemes.outputs.has_schemes == 'true'
        working-directory: ${{ matrix.project }}
        run: |
          scheme=$(head -1 ../schemes_${{ matrix.project//\//_ }}.txt)
          xcodebuild test -scheme "$scheme" -destination 'platform=iOS Simulator,name=iPhone 16' -enableCodeCoverage YES -resultBundlePath $XCODE_COVERAGE_RESULT_BUNDLE | xcpretty 2>&1 | tee ../xcode_test_log_${{ matrix.project//\//_ }}.txt || exit ${PIPESTATUS[0]}
          mkdir -p ../$COVERAGE_DIR/xcode/${{ matrix.project }}
          cp -R $XCODE_COVERAGE_RESULT_BUNDLE ../$COVERAGE_DIR/xcode/${{ matrix.project }}/
          summary=$(xcrun xccov view --report --json $XCODE_COVERAGE_RESULT_BUNDLE 2>/dev/null || true)
          if [[ -n "$summary" ]]; then echo "$summary" > ../$COVERAGE_DIR/xcode/${{ matrix.project }}/coverage.json; pct=$(jq -r '.targets | map(.lineCoverage) | add / length * 100' ../$COVERAGE_DIR/xcode/${{ matrix.project }}/coverage.json 2>/dev/null || echo 0); printf '%.2f' "$pct" > ../$COVERAGE_DIR/xcode/${{ matrix.project }}/line_coverage_pct.txt; fi
      - name: Conditional Node Tests
        run: |
          if [[ -f package.json ]]; then npm install; npm test 2>&1 | tee node_test_log_${{ matrix.project//\//_ }}.txt || echo failed >> node_failures.txt; fi
      - name: Conditional Python Tests
        run: |
          if ls *.py >/dev/null 2>&1 || [[ -f requirements.txt || -f pyproject.toml ]]; then python3 -m venv .venv; source .venv/bin/activate; pip install --upgrade pip; [[ -f requirements.txt ]] && pip install -r requirements.txt || true; [[ -f pyproject.toml ]] && pip install . || true; pip install pytest || true; pytest -q 2>&1 | tee python_test_log_${{ matrix.project//\//_ }}.txt || echo failed >> python_failures.txt; fi
      - name: Summaries & Threshold
        run: |
          mkdir -p $COVERAGE_DIR/summaries
          overall_file=$COVERAGE_DIR/summaries/${{ matrix.project//\//_ }}_overall_pct.txt
          # Prefer Xcode coverage if present (richer target-level); fallback to SwiftPM
          if [[ -f $COVERAGE_DIR/xcode/${{ matrix.project }}/line_coverage_pct.txt ]]; then cp $COVERAGE_DIR/xcode/${{ matrix.project }}/line_coverage_pct.txt $overall_file; elif [[ -f $COVERAGE_DIR/swiftpm/${{ matrix.project }}/line_coverage_pct.txt ]]; then cp $COVERAGE_DIR/swiftpm/${{ matrix.project }}/line_coverage_pct.txt $overall_file; fi
          if [[ -f $overall_file ]]; then pct=$(cat $overall_file); echo "Coverage $pct% vs min $COVERAGE_MIN_PCT%"; awk -v p=$pct -v m=$COVERAGE_MIN_PCT 'BEGIN{exit (p<m)}' || { echo below threshold; exit 1; }; else echo "No coverage file"; fi
      - name: Extract Flaky Candidates
        if: always()
        run: |
          mkdir -p flaky
          # Simple heuristic: tests that appear as both passed and failed in logs
          logs="xcode_test_log_${{ matrix.project//\//_ }}.txt spm_test_log_${{ matrix.project//\//_ }}.txt"
          passed=$(grep -hE "Test Case" $logs 2>/dev/null | grep -iE "passed|succeeded" | grep -oE 'test[[:alnum:]_]+' | sort -u || true)
          failed=$(grep -hE "Test Case" $logs 2>/dev/null | grep -iE "failed|error" | grep -oE 'test[[:alnum:]_]+' | sort -u || true)
          flaky_list=$(comm -12 <(printf '%s\n' $passed) <(printf '%s\n' $failed) 2>/dev/null || true)
          out_json=flaky/${{ matrix.project//\//_ }}_flaky.json
          echo "[]" > "$out_json"
          for t in $flaky_list; do
            echo "$t" | jq -R '{test: .}' | jq -s '.[0]' > tmp.json
            jq -s '.[0] + [.[1]]' "$out_json" tmp.json > tmp2.json && mv tmp2.json "$out_json"
          done
          rm -f tmp.json
    - name: Upload Coverage & Flaky Artifacts
        if: always()
        uses: actions/upload-artifact@ea165f8d65b6e75b540449e92b4886f43607fa02
        with:
      name: "ci-${{ matrix.project//\//_ }}"
          path: |
            ${{ github.workspace }}/$COVERAGE_DIR/**
            ${{ github.workspace }}/flaky/**
            ${{ github.workspace }}/*test_log_${{ matrix.project//\//_ }}.txt
      - name: Job Summary
        if: always()
        run: |
          echo "### ${{ matrix.project }}" >> $GITHUB_STEP_SUMMARY
          file=$COVERAGE_DIR/summaries/${{ matrix.project//\//_ }}_overall_pct.txt
          if [[ -f $file ]]; then echo "Coverage: $(cat $file)%" >> $GITHUB_STEP_SUMMARY; fi
          fjson=flaky/${{ matrix.project//\//_ }}_flaky.json
          if [[ -s $fjson ]]; then echo "Potential flaky tests:" >> $GITHUB_STEP_SUMMARY; jq -r '.[] | "- " + .test + " (passes: " + (.passes|tostring) + ", fails: " + (.fails|tostring) + ")"' $fjson >> $GITHUB_STEP_SUMMARY; fi

  aggregate:
    runs-on: ubuntu-latest
    needs: build-test
    if: always()
    outputs:
      avg: ${{ steps.agg.outputs.avg }}
    steps:
      - uses: actions/checkout@34e114876b0b11c390a56381ad16ebd13914f8d5
      - name: Download artifacts
        uses: actions/download-artifact@d3f86a106a0bac45b974a628896c90dbdf5c8093
        with:
          path: artifacts
          pattern: ci-*
          merge-multiple: true
      - name: Aggregate coverage & badge & flaky
        id: agg
        run: |
          set -euo pipefail
          summary_files=$(find artifacts -name '*_overall_pct.txt' || true)
          total=0; count=0; projjson="[]"
          for f in $summary_files; do
            pct=$(cat "$f")
            name=$(basename "$f" | sed 's/_overall_pct.txt//')
            projjson=$(jq --arg n "$name" --arg p "$pct" '. + [{project:$n,coverage:($p|tonumber)}]' <<<"$projjson")
            total=$(python3 -c "print(float('$total')+float('$pct'))")
            count=$((count+1))
          done
          avg=0
          if [[ $count -gt 0 ]]; then avg=$(python3 -c "print(f'{float($total)/int($count):.2f}')"); fi
          mkdir -p coverage-badge
          color=$(python3 -c "import sys; v=float(sys.argv[1]) if len(sys.argv)>1 else 0; print('brightgreen' if v>=90 else ('green' if v>=80 else ('yellow' if v>=70 else ('orange' if v>=55 else 'red'))))" "$avg")
          printf '{ "schemaVersion": 1, "label": "coverage", "message": "%s%%", "color": "%s" }\n' "$avg" "$color" > coverage-badge/coverage.json
          echo "$projjson" > coverage-badge/projects.json
          # Combine flaky lists
          flakyjson="[]"
          for fj in $(find artifacts -name '*_flaky.json' -size +2c 2>/dev/null); do
            arr=$(jq -c '.' "$fj")
            flakyjson=$(jq -c --argjson add "$arr" '. + $add' <<<"$flakyjson")
          done
          echo "$flakyjson" > coverage-badge/flaky.json
          # Compute deltas if baseline exists
          if [[ "${{ needs.prepare-matrix.outputs.has_baseline }}" == "true" ]]; then
            echo "Baseline present";
            echo '${{ needs.prepare-matrix.outputs.baseline_json }}' > coverage-badge/baseline.json
            jq -c --slurpfile base coverage-badge/baseline.json '.[0] as $cur | $cur | map(. + {delta: ( .coverage - ( ($base[0][]? | select(.project==.project) | .coverage) // .coverage ))})' coverage-badge/projects.json > coverage-badge/projects_with_delta.json || cp coverage-badge/projects.json coverage-badge/projects_with_delta.json
          else
            cp coverage-badge/projects.json coverage-badge/projects_with_delta.json
          fi
          echo "avg=$avg" >> $GITHUB_OUTPUT
    - name: Upload badge artifact
        uses: actions/upload-artifact@ea165f8d65b6e75b540449e92b4886f43607fa02
        with:
      name: "coverage-badge"
          path: coverage-badge

  pr-comment:
    runs-on: ubuntu-latest
    needs: [aggregate, prepare-matrix]
    if: github.event_name == 'pull_request'
    steps:
      - uses: actions/checkout@34e114876b0b11c390a56381ad16ebd13914f8d5
      - uses: actions/download-artifact@d3f86a106a0bac45b974a628896c90dbdf5c8093
        with:
          name: coverage-badge
          path: badge
      - name: Generate PR Comment
        id: comment
        run: |
          echo "## Coverage Summary" > comment.md
          if [[ -f badge/projects_with_delta.json ]]; then
            echo '' >> comment.md
            echo '| Project | Coverage | Î” vs Baseline |' >> comment.md
            echo '|---------|----------|---------------|' >> comment.md
            jq -r '.[] | "| " + .project + " | " + (.coverage|tostring) + "% | " + ( ( .delta // 0 ) | tostring ) + "% |"' badge/projects_with_delta.json >> comment.md || true
          fi
          if [[ -s badge/flaky.json ]]; then
            echo '' >> comment.md
            echo '### Potential Flaky Tests' >> comment.md
            jq -r '.[] | "- " + .test + " (passes: " + (.passes|tostring) + ", fails: " + (.fails|tostring) + ")"' badge/flaky.json >> comment.md
          fi
          echo '' >> comment.md
          echo "_Generated by unified-ci.enhanced.yml_" >> comment.md
      - uses: actions/github-script@f28e40c7f34bde8b3046d885e986cb6290c5673b
        with:
          script: |
            const fs = require('fs');
            const body = fs.readFileSync('comment.md','utf8');
            const {owner, repo, number} = context.issue;
            const comments = await github.rest.issues.listComments({owner, repo, issue_number: number});
            const marker = '## Coverage Summary';
            const existing = comments.data.find(c => c.body.startsWith(marker));
            if (existing) {
              await github.rest.issues.updateComment({owner, repo, comment_id: existing.id, body});
            } else {
              await github.rest.issues.createComment({owner, repo, issue_number: number, body});
            }

  update-baseline:
    runs-on: ubuntu-latest
    needs: aggregate
    if: github.ref == 'refs/heads/main' && github.event_name == 'push'
    permissions:
      contents: write
    steps:
      - uses: actions/checkout@34e114876b0b11c390a56381ad16ebd13914f8d5
      - uses: actions/download-artifact@d3f86a106a0bac45b974a628896c90dbdf5c8093
        with:
          name: coverage-badge
          path: badge
      - name: Update baseline file
        run: |
          if [[ -f badge/projects.json ]]; then
            mkdir -p $(dirname $COVERAGE_BASELINE_FILE)
            # Only update if average improves by >=0.5% or baseline missing
            avg=$(jq '[.[].coverage]|add/length' badge/projects.json 2>/dev/null || echo 0)
            if [[ ! -f $COVERAGE_BASELINE_FILE ]]; then cp badge/projects.json $COVERAGE_BASELINE_FILE; echo "Baseline created"; else
              oldavg=$(jq '[.[].coverage]|add/length' $COVERAGE_BASELINE_FILE 2>/dev/null || echo 0)
              delta=$(python3 -c "print(float('$avg')-float('$oldavg'))")
              if awk -v d="$delta" 'BEGIN{exit (d>=0.5)?0:1}'; then
                cp badge/projects.json "$COVERAGE_BASELINE_FILE"
                echo "Baseline updated: $oldavg -> $avg"
              else
                echo "Baseline not updated (delta $delta < 0.5)"
              fi
            fi
          fi
      - name: Commit baseline (if changed)
        run: |
          if git diff --quiet --exit-code $COVERAGE_BASELINE_FILE 2>/dev/null; then echo "No baseline changes"; else
            git config user.name 'github-actions'; git config user.email 'actions@users.noreply.github.com'
            git add $COVERAGE_BASELINE_FILE
            git commit -m 'ci: update coverage baseline'
            git push
          fi
