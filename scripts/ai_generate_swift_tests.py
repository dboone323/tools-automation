#!/usr/bin/env python3
"""
AI-Assisted Swift Unit Test Generator
- Scans Projects/* for Swift files (excluding Tests and AutoTests)
- Heuristically extracts type names (class/struct/enum) and public methods
- Generates XCTestCase skeletons with TODOs for developer to fill in
- Writes to Projects/<Project>/AutoTests/GeneratedTests_<YYYYMMDD>.swift

Safe and idempotent:
- Won't overwrite existing generated file of the same date; appends unique suffix
- Skips files in Tests directories
- Avoids duplicate test case generation per type in a single output

Note: Adding files to Xcode test targets is still manual.
"""
import os
import re
import sys
import json
import hashlib
from datetime import datetime
from pathlib import Path

WORKSPACE_ROOT = Path(__file__).resolve().parents[2]
PROJECTS_DIR = WORKSPACE_ROOT / "Projects"

TYPE_REGEX = re.compile(
    r"^\s*(public\s+|internal\s+|open\s+|final\s+)?(class|struct|enum)\s+([A-Za-z_][A-Za-z0-9_]*)(\s*:\s*[^\{]+)?\s*\{",
    re.MULTILINE,
)
METHOD_REGEX = re.compile(
    r"^\s*(public\s+|internal\s+|open\s+)?(static\s+|class\s+)?func\s+([A-Za-z_][A-Za-z0-9_]*)\s*\(([^)]*)\)",
    re.MULTILINE,
)

EXCLUDE_DIR_NAMES = {
    "Tests",
    "UnitTests",
    "UITests",
    "AutoTests",
    ".build",
    "DerivedData",
    "Pods",
}

HEADER = """// Auto-generated by ai_generate_swift_tests.py on {date}
// Project: {project}
// This file contains XCTest skeletons generated from discovered Swift types.
// Add this file to your Test target in Xcode to activate.

import XCTest
@testable import {module}

"""

TEST_TEMPLATE = """
final class {type_name}Tests: XCTestCase {{
    override func setUp() {{
        super.setUp()
        // TODO: Initialize shared resources for {type_name}
    }}

    override func tearDown() {{
        // TODO: Clean up resources
        super.tearDown()
    }}
{method_tests}
}}
"""

METHOD_TEST_TEMPLATE = """
    func test_{method_name}_behaviour() throws {{
        // GIVEN: Setup for {type_name}.{method_name}
        // TODO: Initialize subject under test

        // WHEN: Invoke the method
        // TODO: Call {type_name}.{method_name} with appropriate params

        // THEN: Validate results
        // TODO: Add XCTAssert* checks for expected behaviour
        XCTFail("Test not implemented: {type_name}.{method_name}()")
    }}
"""


def is_excluded(path: Path) -> bool:
    parts = set(p for p in path.parts)
    return any(name in EXCLUDE_DIR_NAMES for name in parts)


def find_swift_files(project_dir: Path):
    for root, dirs, files in os.walk(project_dir):
        # Prune excluded directories
        dirs[:] = [d for d in dirs if d not in EXCLUDE_DIR_NAMES]
        for f in files:
            if f.endswith(".swift"):
                file_path = Path(root) / f
                if not is_excluded(file_path):
                    yield file_path


def extract_types_and_methods(swift_code: str):
    types = []
    for match in TYPE_REGEX.finditer(swift_code):
        type_name = match.group(3)
        types.append(type_name)
    # Restrict methods to avoid overwhelming stubs; pick public/non-internal names
    method_names = set()
    for mm in METHOD_REGEX.finditer(swift_code):
        name = mm.group(3)
        # Skip init, private underscore prefixes, and trivial getters
        if name.startswith("_") or name.startswith("init"):
            continue
        method_names.add(name)
    return types, sorted(method_names)[:6]  # cap per file to keep manageable


def unique_output_path(base_dir: Path, base_name: str) -> Path:
    candidate = base_dir / base_name
    if not candidate.exists():
        return candidate
    # Append short hash for uniqueness
    stem = base_name[:-7] if base_name.endswith(".swift") else base_name
    # Use sha256 for stronger hash even though this is used only to ensure unique filenames
    suffix = hashlib.sha256(str(datetime.now().timestamp()).encode()).hexdigest()[:6]
    return base_dir / f"{stem}_{suffix}.swift"


def generate_tests_for_project(project_dir: Path) -> dict:
    project_name = project_dir.name
    auto_tests_dir = project_dir / "AutoTests"
    auto_tests_dir.mkdir(parents=True, exist_ok=True)
    date_str = datetime.now().strftime("%Y%m%d")
    out_file = unique_output_path(auto_tests_dir, f"GeneratedTests_{date_str}.swift")

    discovered = {}
    for swift_file in find_swift_files(project_dir):
        try:
            code = swift_file.read_text(encoding="utf-8", errors="ignore")
        except Exception:
            continue
        types, methods = extract_types_and_methods(code)
        for t in types:
            discovered.setdefault(t, set()).update(methods)

    if not discovered:
        return {"project": project_name, "status": "no_types_found"}

    module_name = project_name  # heuristic; may differ from target name
    content = HEADER.format(
        date=datetime.now().isoformat(), project=project_name, module=module_name
    )

    # Cap total number of test classes to avoid oversized files
    MAX_TYPES = 50
    items = sorted(discovered.items())[:MAX_TYPES]
    for t_name, m_set in items:
        method_tests = "".join(
            METHOD_TEST_TEMPLATE.format(type_name=t_name, method_name=m)
            for m in sorted(m_set) or ["example"]
        )
        content += TEST_TEMPLATE.format(type_name=t_name, method_tests=method_tests)

    out_file.write_text(content, encoding="utf-8")
    return {"project": project_name, "status": "ok", "output": str(out_file)}


def main(argv):
    import argparse

    parser = argparse.ArgumentParser(description="Generate Swift XCTest skeletons")
    parser.add_argument(
        "--project", help="Project name to target; default=all", default=None
    )
    args = parser.parse_args(argv)

    results = []
    targets = []
    if args.project:
        p = PROJECTS_DIR / args.project
        if not p.exists() or not p.is_dir():
            print(json.dumps({"error": f"Project not found: {args.project}"}))
            return 2
        targets = [p]
    else:
        targets = [d for d in PROJECTS_DIR.iterdir() if d.is_dir()]

    for proj in targets:
        res = generate_tests_for_project(proj)
        results.append(res)
        print(
            f"[ai-generate-tests] {proj.name}: {res.get('status')} -> {res.get('output', '')}"
        )

    # Write a summary JSON under Tools/Automation/results
    results_dir = WORKSPACE_ROOT / "Tools" / "Automation" / "results"
    results_dir.mkdir(parents=True, exist_ok=True)
    summary_path = (
        results_dir
        / f"ai_generate_swift_tests_{datetime.now().strftime('%Y%m%d_%H%M%S')}.json"
    )
    summary_path.write_text(json.dumps(results, indent=2), encoding="utf-8")
    return 0


if __name__ == "__main__":
    sys.exit(main(sys.argv[1:]))
